Объектно-ориентированное программирование ( ООП ) — это парадигма программирования, основанная на концепции « объектов », которые могут содержать данные и код : данные в виде полей (часто называемых атрибутами или свойствами ) и код в виде процедур. (часто называемые методами ).
В объектно-ориентированном программировании основное внимание уделяется созданию объектов , которые вместе содержат как данные, так и функциональные возможности. Обычно каждое определение объекта соответствует некоторому объекту или понятию в реальном мире, а функции, которые работают с этим объектом, соответствуют способам взаимодействия объектов реального мира.

Состояние объекта представляет собой то, что объект знает о себе. Состояние хранится в переменных экземпляра.
======================================================================================================================== 
Например, как мы видели с объектами черепах, у каждой черепахи есть состояние, состоящее из положения черепахи, ее цвета, направления и так далее. Каждая черепаха также может двигаться вперед, назад или поворачиваться вправо или влево. Отдельные черепахи отличаются тем, что, несмотря на то, что все они черепахи, они различаются конкретными значениями отдельных атрибутов состояния (возможно, они находятся в другом месте или имеют другой заголовок).
======================================================================================================================== 

Каждый класс должен иметь метод со специальным именем __init__. Этот метод инициализатора , часто называемый конструктором

Параметр self(вы можете выбрать любое другое имя, но никто этого не делает!) автоматически устанавливается для ссылки на только что созданный объект, который необходимо инициализировать.
self - служит ссылкой на сам объект, который, в свою очередь, дает доступ к данным состояния внутри объекта.

Может быть полезно думать о классе как о фабрике по производству объектов. Сам класс не является экземпляром точки, но он содержит механизмы для создания экземпляров точки. Каждый раз, когда вы вызываете конструктор, вы просите фабрику создать для вас новый объект. Когда объект сходит с производственной линии, выполняется метод его инициализации, чтобы правильно настроить объект с заводскими настройками по умолчанию.

Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом.
Дескрипторы вызываются только для объектов или классов нового стиля (класс является таким, если наследует от object или type ). Дескрипторы — это мощный протокол с широкой областью применения. Они являются тем механизмом, который стоит за свойствами, методами, статическими методами, методами класса и вызовом super() 

Метод __str__отвечает за возврат строкового представления, определенного создателем класса. Другими словами, вы, как программист, можете выбрать, как Pointдолжен выглядеть документ при печати. В данном случае мы решили, что строковое представление будет включать значения x и y, а также некоторый идентифицирующий текст. Требуется, чтобы __str__метод создавал и возвращал строку.

======================================================================================================================== 
Прежде чем вы решите определить новый класс, необходимо помнить о нескольких вещах и задавать себе вопросы:
С какими данными вы хотите иметь дело? (Данные о множестве песен из iTunes? Данные о множестве твитов из Twitter? Данные о множестве поисковых запросов по хэштегам в Twitter? Два числа, представляющие координаты точки на двумерной плоскости?)

Что будет представлять один экземпляр вашего класса? Другими словами, какая новая вещь в вашей программе должна иметь причудливую функциональность? Одна песня? Один хэштег? Один твит? Один пункт? Ответ на этот вопрос должен помочь вам решить, как назвать класс, который вы определяете.

Какую информацию должен иметь каждый экземпляр в качестве переменных экземпляра? Это связано с тем, что представляет экземпляр. Посмотрите, сможете ли вы превратить это в предложение. «Каждый экземпляр представляет одну <песню>, и каждая <песня> имеет <исполнитель> и <название> в качестве переменных экземпляра». Или: «Каждый экземпляр представляет <твит>, и каждый <твит> имеет <пользователя (который опубликовал его)> и <строку содержимого сообщения> в качестве переменных экземпляра».

Какие методы экземпляра должны быть у каждого экземпляра? Что должен уметь делать каждый экземпляр ? Продолжая использовать те же примеры: возможно, у каждой песни есть метод, который использует API текстов для получения длинной строки текста. Возможно, у каждой песни есть метод, возвращающий строку с именем исполнителя. Или для твита, может быть, у каждого твита есть метод, который возвращает длину сообщения твита. (Неистовствовать!)

Как должна выглядеть печатная версия экземпляра? (Этот вопрос поможет вам определить, как написать __str__метод.) Возможно, «каждая распечатанная песня будет содержать название песни и имя исполнителя». или «Каждый распечатанный твит будет содержать имя пользователя, опубликовавшего его, и содержание сообщения твита».
