# Ниже у нас есть функция, которая удаляет элемент из списка ввода. Запустите его, чтобы увидеть, что он делает.
import random
my_list = [27, 5, 9, 6, 8]


def RemoveValue(myVal):
    my_list.remove(myVal)
    return my_list


print(RemoveValue(27))

# Мы использовали функцию RemoveValue() для удаления числа 27 из заданного списка. Большой! Функция, кажется, работает нормально. Однако возникает проблема, когда мы снова пытаемся вызвать функцию на числе 27. Запустите следующую ячейку, чтобы увидеть, что произойдет.

# print(RemoveValue(27))

# Из приведенного выше вывода мы видим, что наша функция теперь вызывает ValueError. Это потому, что мы пытаемся удалить из списка номер, которого нет в списке. Когда мы удалили 27 из списка в первый раз, его больше не было в списке для удаления во второй раз. Python сообщает нам, что число 27 больше не имеет смысла для нашей функции RemoveValue().

# Мы хотели бы взять под контроль сообщения об ошибках и предотвратить эту ошибку. Заполните пустые поля ниже, чтобы вызвать ValueError в функции RemoveValue(), если значение отсутствует в списке. В сообщении об ошибке может быть сказано что-то очевидное, например «Значение должно быть в данном списке».


def RemoveValue(myVal):
    if myVal not in my_list:
        raise ValueError(f'{myVal} not on the list')
    else:
        my_list.remove(myVal)
    return my_list


# print(RemoveValue(27))

# Правильно ли напечатано ваше сообщение об ошибке? Был ли вывод примерно таким: ValueError: Значение должно быть в данном списке? Если нет, вернитесь к предыдущей ячейке и убедитесь, что вы правильно заполнили пробелы. Если ваше сообщение об ошибке напечатано правильно, отлично! Вы находитесь на пути к освоению основ обработки ошибок и исключений.

# Теперь давайте рассмотрим другую функцию. Ниже у нас есть функция, которая сортирует входной список в алфавитном порядке. Запустите его, чтобы увидеть, что он делает.

my_word_list = ['east', 'after', 'up', 'over', 'inside']


def OrganizeList(myList):
    myList.sort()
    return myList


print(OrganizeList(my_word_list))

# Мы использовали функцию OrganizeList() для сортировки заданного списка в алфавитном порядке. Функция, кажется, работает нормально. Однако возникает проблема, когда мы пытаемся вызвать функцию для списка, содержащего числовые значения. Запустите следующую ячейку, чтобы увидеть, что произойдет.

my_new_list = [6, 3, 8, "12", 42]
# print(OrganizeList(my_new_list))

# Из приведенного выше вывода мы видим, что наша функция теперь вызывает TypeError. Это связано с тем, что функция OrganizeList() подходит для списков, заполненных только строками. Возьмите под свой контроль сообщения об ошибках и предупредите эту ошибку, заполнив пробелы ниже, чтобы добавить аргумент типа утверждения, который проверяет, заполнен ли входной список только строками. В сообщении об ошибке может быть сказано что-то вроде «Список слов должен быть списком строк».


def OrganizeList(myList):
    for item in myList:
        assert type(item) == str, "Word list must be a list of strings"
    myList.sort()
    return myList


# print(OrganizeList(my_new_list))

# Правильно ли напечатано ваше сообщение об ошибке? Был ли вывод примерно таким: AssertionError: Список слов должен быть списком строк? Если нет, вернитесь к предыдущей ячейке и убедитесь, что вы правильно заполнили пробелы. Если ваше сообщение об ошибке напечатано правильно, отлично! Вы еще на один шаг приблизились к освоению основ обработки ошибок и исключений.

# Давайте посмотрим на последний блок кода. Приведенная ниже функция Guess() берет список участников, присваивает каждому случайное число от 1 до 9 и сохраняет эту информацию в словаре с именем участника в качестве ключа. Затем он возвращает True, если Ларри был присвоен номер 9, и False, если это не так. Запустите его, чтобы увидеть, что он делает.


participants = ['Jack', 'Jill', 'Larry', 'Tom']


def Guess(participants):
    my_participant_dict = {}
    try:
        for participant in participants:
            my_participant_dict[participant] = random.randint(1, 9)
        if my_participant_dict['Larry'] == 9:
            return True
        else:
            return False
    except Exception:
        return None


print(Guess(participants))

# Код, кажется, работает нормально. Однако есть некоторые вещи, которые могут пойти не так, поэтому найдите часть, которая может вызвать исключение, и оберните ее в блок try-except, чтобы обеспечить разумное поведение. Сделайте это в ячейке ниже. Закодируйте свою функцию так, чтобы она возвращала None в случае возникновения исключения.
# Вызовите вашу исправленную функцию `Guess()` со следующим списком участников.
participants = ['Cathy', 'Fred', 'Jack', 'Tom']
print(Guess(participants))

# Был ли приведенный выше вывод None? Если нет, вернитесь к блоку кода, содержащему вашу исправленную функцию Guess(), и внесите изменения, чтобы вывод для предыдущего блока кода был None. Если приведенный выше вывод действительно был None, поздравляем! Вы освоили основы обработки ошибок и исключений в Python, и вы все сделали с этой тетрадью!
