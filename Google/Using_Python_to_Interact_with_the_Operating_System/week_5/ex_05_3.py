# Ниже у нас есть код, который составляет список определенных букв, найденных в любой строке. Если вы запустите его, вы увидите, что он делает.
import unittest
import re

my_txt = "An investment in knowledge pays the best interest."


def LetterCompiler(txt):
    result = re.findall(r'([a-c]).', txt)
    return result


print(LetterCompiler(my_txt))

# Из вывода видно, что функция LetterCompiler() находит все совпадения для букв от a до c во входной строке, если за ними следует другой символ, и возвращает их в виде списка строк, где каждая строка представляет одно совпадение. Хороший.

# Но можем ли мы быть уверены, что эта функция всегда будет делать то, что мы от нее ожидаем? Нам нужно написать код, который поможет нам выявлять ошибки, ошибки и баги. Этот код должен автоматизировать процесс проверки соответствия возвращаемого значения нашего кода ожиданиям путем динамической подачи в него тестовых случаев. Поскольку мы динамически подаем разные строки, было бы разумно создать модульные тесты для нашего кода. Для этого мы можем использовать модуль unittest.

# Заполните пробелы ниже, чтобы создать автоматический тест unint, который проверяет, имеют ли входные строки правильный список совпадений строк.


class TestCompiler(unittest.TestCase):

    def test_basic(self):
        testcase = "The best preparation for tomorrow is doing your best today."
        expected = ['b', 'a', 'a', 'b', 'a']
        self.assertEqual(LetterCompiler(LetterCompiler(testcase)), expected)


# Теперь, когда ваш автоматический тест написан, вам нужно вызвать функцию unittest.main(), чтобы запустить тест. Важно отметить, что конфигурация для запуска модульных тестов в Jupyter отличается от конфигурации для запуска модульных тестов из командной строки. Запуск unittest.main() в Jupyter приведет к ошибке. Вы можете увидеть это, запустив следующую ячейку, чтобы выполнить автоматический тест.
unittest.main()

# Ой! SystemExit: True означает, что произошла ошибка, как и ожидалось. Причина в том, что unittest.main() просматривает sys.argv. В Jupyter по умолчанию первый параметр sys.argv — это то, что запускает ядро ​​Jupyter, чего нельзя сказать о его выполнении из командной строки. Этот параметр по умолчанию передается в unittest.main() в качестве атрибута, если вы явно не передаете ему атрибуты, и поэтому он вызывает ошибку о том, что файл подключения к ядру не является допустимым атрибутом. Передача явного списка функции unittest.main() предотвращает просмотр sys.argv.

# Давайте передадим ему список ['first-arg-is-ignored'], например. Кроме того, мы передадим ей параметр exit = False, чтобы модуль unittest.main() не останавливал процесс ядра. Запустите следующую ячейку с параметрами argv и exit, переданными в unittest.main(), чтобы повторно запустить автоматический тест.

unittest.main(argv=['first-arg-is-ignored'], exit=False)
# Прошел ли ваш автоматический тест? Был ли результат в порядке? Если нет, вернитесь к коду автоматического теста и убедитесь, что вы правильно заполнили пробелы. Если ваш автоматический тест прошел успешно, отлично! Вы успешно заполнили пробелы, чтобы создать автоматический тест, который проверяет, имеют ли входные строки правильный список совпадений строк.

# На данный момент это отличная работа, но ваш автоматический тест включает только один тестовый пример. Вам нужно заставить его расти. Вы можете ввести больше строк в качестве тестовых примеров, чтобы проверить, работает ли ваш код в общем случае. Но вы также должны увидеть, что происходит, когда вы даете ему какие-то данные, с которыми вы, возможно, не ожидаете, что он столкнется при нормальной работе.

# Пограничные случаи — это входные данные для кода, которые дают неожиданные результаты и находятся на крайних границах диапазонов входных данных, с которыми, как мы предполагаем, программы обычно будут работать. Можете ли вы использовать ячейку ниже, чтобы написать несколько крайних случаев? Мы уже заполнили для вас еще один тест! Как бы то ни было, этот тест будет работать нормально. Можете ли вы придумать хотя бы один тестовый пример, который, по вашему мнению, может привести к неправильному возвращаемому значению? Никаких неправильных ответов! Не стесняйтесь играть.


class TestCompiler2(unittest.TestCase):

    def test_two(self):
        testcase = "A b c d e f g h i j k l m n o q r s t u v w x y z"
        expected = ['b', 'c']
        self.assertEqual(LetterCompiler(testcase), expected)

# EDGE CASES HERE


unittest.main(argv=['first-arg-is-ignored'], exit=False)

# Вы нашли крайние случаи? Если нет, продолжайте работать над этим. Выбор тестовых случаев может быть упражнением в творчестве. Придумывать разные способы взлома кода может быть очень весело! Когда вы обнаружили крайний случай, подумайте о специальной обработке в вашем скрипте, чтобы ваш код продолжал работать правильно.
# Если у вас нет идей: попробуйте удалить пробелы и выяснить, почему они были в тестовом примере. Это дает вам идею для других тестов?
# Когда вы нашли хотя бы один пограничный случай, вы закончили с этой записной книжкой. Вы должны воспользоваться моментом, чтобы подумать о том, что вы сделали до сих пор. Это очень впечатляет и прекрасно впишется в ваш набор ИТ-инструментов.
